name: Adding documentation and update GitHub Page
run-name: Action on Merged main by ${{ github.actor }} 

on:
  workflow_call:
    inputs:
    
      image_to_use:
        required: true
        type: string
      
    secrets:
      PAT:
        required: false
      
jobs:
  Adding_documentation_files_and_publish_page:
    runs-on: ubuntu-latest
    container:
      image: ${{ inputs.image_to_use }}
      credentials:
         username: ${{ github.actor }}
         password: ${{ secrets.GITHUB_TOKEN }}
         
    steps:
      - run: echo "Checking in ${{ inputs.image_to_use }}"
      - uses: actions/checkout@v3
        with:
          token: ${{secrets.GITHUB_TOKEN}}
          
      - name: Generating files with Document
        id: prepare-push 
        if: ${{ success() }}
        run: |
          export current_wd="/__w/${GITHUB_REPOSITORY#*/}/${GITHUB_REPOSITORY#*/}"
          cd $current_wd
          
          export MY_GIT_TOKEN=${{ secrets.GITHUB_TOKEN }}
          export MY_GIT_USERNAME=${{ github.actor }}
          export MY_GIT_EMAIL=${{ github.event.pusher.email }}
          
          git config --global user.name "$MY_GIT_USERNAME"
          git config --global user.email "$MY_GIT_EMAIL"
          git config --global url."https://api:$MY_GIT_TOKEN@github.com/".insteadOf "https://github.com/"
          git config --global url."https://ssh:$MY_GIT_TOKEN@github.com/".insteadOf "ssh://git@github.com/"
          git config --global url."https://git:$MY_GIT_TOKEN@github.com/".insteadOf "git@github.com:"
          
          git config --global --add safe.directory "$current_wd"
          
          git clone https://github.com/${GITHUB_REPOSITORY}.git
          
          cd ${GITHUB_REPOSITORY#*/}
          
          apt update && apt-get install -y --no-install-recommends pandoc
          
          git checkout main
          
          R -e '.libPaths(c("/renv/library/R-4.1/x86_64-pc-linux-gnu",.libPaths()));library(devtools);document();library(pkgdown);build_site_github_pages()'
          
          cat $(pwd)/NAMESPACE

          git add ./NAMESPACE ./man/*
          
          echo $(git commit -a -m "Adding auto-generated files") > commit_log.log
          
          cat commit_log.log
          
          echo "Performing check now"
          export nothing_for_commit="$(grep -Po "nothing to commit" commit_log.log)"
          
          if [ -n "${nothing_for_commit}" ]; then
            echo "Commit check failed with message: $nothing_for_commit" 
          else
            echo "Pushing changes now."
            git push -f origin main
          fi

          echo "Create release tag for Continueous Deployment"

          latest_commit_hash=$(git rev-parse HEAD)
          TAG_NAME="continuous_deployment"

          # Check if the tag exists locally
          if git rev-parse -q --verify "refs/tags/$TAG_NAME" >/dev/null; then
              echo "Local tag '$TAG_NAME' exists. Deleting..."
              git tag -d "$TAG_NAME"
          else
              echo "Local tag '$TAG_NAME' does not exist."
          fi

          # Check if the tag exists remotely
          if git ls-remote --tags origin | grep -q "refs/tags/$TAG_NAME"; then
              echo "Remote tag '$TAG_NAME' exists. Deleting..."
              git push origin ":refs/tags/$TAG_NAME"
          else
              echo "Remote tag '$TAG_NAME' does not exist."
          fi

          git tag \
            -a "$TAG_NAME" \
            -m "Automatically tagged latest commit for continuous_deployment." \
            $latest_commit_hash

          git push origin $TAG_NAME

          echo "Now pushing GitHub Page Documents"

          git add ./docs/*

          git commit -a -m "Documenting doc files."
          
          echo $(git checkout github_page) > checkout_check.log
          
          export no_branch="$(grep -Po "did not match any file(s) known" checkout_check.log)"
          
          if [ -n "${no_branch}" ]; then
            git checkout -b github_page
          fi
          
          git checkout -f main ./docs
          
          echo $(git commit -a -m "Updating GitHub Page") > commit_log.log
          
          cat commit_log.log
          
          export nothing_for_commit="$(grep -Po "nothing to commit" commit_log.log)"
          
          if [ -n "${nothing_for_commit}" ]; then
            echo "Commit check failed with message: $nothing_for_commit" 
          else
            echo "Pushing changes now."
            git push -f origin github_page
          fi
          
          echo "Process completed."

      - name: Generating Conda Package
        id: prepare-conda-pkg 
        if: ${{ success() }}
        run: |

          export current_wd="/__w/${GITHUB_REPOSITORY#*/}/${GITHUB_REPOSITORY#*/}"
          cd $current_wd
          cd ../
          mkdir conda_pkg_building
          cd conda_pkg_building

          CONDA_DIR=$(pwd)
          
          export MY_GIT_TOKEN=${{ secrets.GITHUB_TOKEN }}
          export MY_GIT_USERNAME=${{ github.actor }}
          export MY_GIT_EMAIL=${{ github.event.pusher.email }}
          
          git config --global user.name "$MY_GIT_USERNAME"
          git config --global user.email "$MY_GIT_EMAIL"
          git config --global url."https://api:$MY_GIT_TOKEN@github.com/".insteadOf "https://github.com/"
          git config --global url."https://ssh:$MY_GIT_TOKEN@github.com/".insteadOf "ssh://git@github.com/"
          git config --global url."https://git:$MY_GIT_TOKEN@github.com/".insteadOf "git@github.com:"
          
          git config --global --add safe.directory "$current_wd"
          
          # Check if conda-build is installed
          if ! command -v conda-build &> /dev/null; then
              echo "conda-build is not installed. Installing..."
              conda install -c conda-forge conda-build
          fi

          echo "#####################################################"

          conda config --add channels conda-forge

          conda skeleton cran \
            --git-tag continuous_deployment \
            https://github.com/${GITHUB_REPOSITORY}.git

          REPO_NAME_LOWERCASE=$(echo ${GITHUB_REPOSITORY#*/} | \
                                tr '[:upper:]' '[:lower:]')

          # Construct the package name as "r-repository_name"
          PACKAGE_NAME="r-$REPO_NAME_LOWERCASE"

          RECIPE_DIR="$(pwd)/$PACKAGE_NAME"

          echo "Recipe is now in $RECIPE_DIR."

          echo "#####################################################"

          # Construct the package name as "r-repository_name"
          BRANCH_NAME="Conda_Package"
          RECIP_DIR="GITHUB_REPOSITORY"

          # Build the Conda package while ignoring tests
          echo "Building Conda Package Now."
          conda-build --R 4.1.3 "$PACKAGE_NAME/"

          PKG_PATH=$(find "/root/miniconda3/conda-bld" -name '*.tar.bz2')
          # --build-only \
          echo "Package build in $PKG_PATH"
          
          echo "#####################################################"
          echo "Package Built! Uploading to $BRANCH_NAME now"         

          cd $current_wd
          cd ${GITHUB_REPOSITORY#*/}          

          # Check if the branch exists remotely
          if git ls-remote --exit-code origin "$BRANCH_NAME" >/dev/null 2>&1; then
              echo "Remote branch '$BRANCH_NAME' exists. Checking it out..."
              git checkout "$BRANCH_NAME"
          else
              echo "Remote branch '$BRANCH_NAME' does not exist. Creating and checking it out..."
              git checkout -b "$BRANCH_NAME"
          fi

          # Move the built package to the current directory
          echo "Building Conda Package Now."
          mv $PKG_PATH .

          git add *.tar.bz2

          current_datetime="$(date +"%Y-%m-%d %H:%M:%S")"
          current_pkg="$(basename "$PKG_PATH")"
          
          echo "current_pkg=$current_pkg" >> "$GITHUB_OUTPUT"
          echo "###############################################################"
          echo "\nCurrent package: ${{ env.current_pkg }}"
          echo "\nDatetime: $current_datetime, Version:  ${{ env.current_pkg }}"
          echo "\nDatetime: $current_datetime, Version:  ${{ env.current_pkg }}" >> README.md

          git commit -a -m "Automatically build conda package"

          git push -f origin $BRANCH_NAME

      - name: Continuous Deployment to NIDAP
        id: nidap-cd
        if: ${{ success() }}
        run: |
          export current_wd="/__w/${GITHUB_REPOSITORY#*/}/${GITHUB_REPOSITORY#*/}"
          cd $current_wd
          cd ${GITHUB_REPOSITORY#*/}

          conda install curl
          
          echo "Package to Upload: ${{ env.current_pkg }}"

          TOKEN="${{ secrets.PAT }}"
          PACKAGE="${{ env.current_pkg }}"
          PLATFORM="linux-64" # replace with the package platform (e.g. noarch, linux-64, osx-64)
          response=$(curl \
                    -H "Authorization: Bearer $TOKEN" \
                    -H "Content-Type: application/octet-stream" \
                    --data-binary "@$PACKAGE" \
                    -XPUT "https://nidap.nih.gov/artifacts/api/repositories/ri.artifacts.main.repository.00852eef-c60b-4b78-8f14-cd48cdfde051/contents/release/conda/$PLATFORM/$PACKAGE" \
                    2>&1)
          
          echo "$response"

          # Check if the response contains an error message
          if echo "$response" | grep -q "Error"; then
            error_message=$(echo "$response" | grep "Error" | sed 's/^Error: //')
            echo "Error message: $error_message"
          else
            echo "Update Sucess!"
            echo "Package ${{ env.current_pkg }} is now on NIDAP."
          fi

          




          

